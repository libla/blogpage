<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>c# on 技术宅的自留地</title>
    <link>https://libla.me/tags/c#/</link>
    <description>Recent content in c# on 技术宅的自留地</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>Copyright &amp;copy; 2020-{now} 技术宅的自留地. All Rights Reserved</copyright>
    <lastBuildDate>Wed, 31 Aug 2016 01:45:56 +0800</lastBuildDate>
    <atom:link href="https://libla.me/tags/c#/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>使用SevenZipSharp出现“Can not load 7-zip library or internal COM error! Message: DLL file does not exist.”的解决方案</title>
      <link>https://libla.me/posts/2016/08/31/sevenzipsharp2/</link>
      <pubDate>Wed, 31 Aug 2016 01:45:56 +0800</pubDate>
      <guid>https://libla.me/posts/2016/08/31/sevenzipsharp2/</guid>
      <description>如果你是从nuget上下载安装的SevenZipSharp库，当你写好相应代码，兴冲冲的启动程序进行测试时，以下画面会让你受到当头一棒： 究其</description>
    </item>
    <item>
      <title>使用SevenZipSharp压缩/解压7z格式</title>
      <link>https://libla.me/posts/2016/08/31/sevenzipsharp/</link>
      <pubDate>Wed, 31 Aug 2016 01:36:48 +0800</pubDate>
      <guid>https://libla.me/posts/2016/08/31/sevenzipsharp/</guid>
      <description>7z格式采用的LZMA算法，号称具有现今最高压缩率。笔者在nuget上搜索7z，在搜索结果中最终选择了SevenZipSharp来进行压缩/</description>
    </item>
    <item>
      <title>使用EPPlus读写xlsx文件</title>
      <link>https://libla.me/posts/2016/08/31/epplus/</link>
      <pubDate>Wed, 31 Aug 2016 00:55:19 +0800</pubDate>
      <guid>https://libla.me/posts/2016/08/31/epplus/</guid>
      <description>朋友有个需求，想对N张excel表做过滤和合并的处理，拜托我写个小程序。因为用户的背景是非专业用户，因此最好的选择是写个GUI程序，再加上读</description>
    </item>
    <item>
      <title>async/await的多线程问题</title>
      <link>https://libla.me/posts/2016/08/14/async/</link>
      <pubDate>Sun, 14 Aug 2016 19:26:40 +0800</pubDate>
      <guid>https://libla.me/posts/2016/08/14/async/</guid>
      <description>今天尝试把.net4.5新增的异步编程模型async/await加入自己的框架，因为从第一印象看，使用async/await的写法实在太方便</description>
    </item>
    <item>
      <title>C#与非托管——封送和自动封送</title>
      <link>https://libla.me/posts/2015/06/08/csnative2/</link>
      <pubDate>Mon, 08 Jun 2015 09:38:21 +0800</pubDate>
      <guid>https://libla.me/posts/2015/06/08/csnative2/</guid>
      <description>之前说到了如何从C函数声明通过简单的查找替换生成一份C#的静态引用声明(C#与非托管——初体验)，因为只是简单说明，所以全部采用的是基础类型</description>
    </item>
    <item>
      <title>C#与非托管——初体验</title>
      <link>https://libla.me/posts/2015/06/07/csnative1/</link>
      <pubDate>Sun, 07 Jun 2015 21:10:40 +0800</pubDate>
      <guid>https://libla.me/posts/2015/06/07/csnative1/</guid>
      <description>P/Invokes初看起来非常简单，利用DllImport进行extern函数的声明，程序就可以在调用extern函数的时候自动查询调用到对</description>
    </item>
    <item>
      <title>C#与非托管——动机</title>
      <link>https://libla.me/posts/2015/06/07/csnative/</link>
      <pubDate>Sun, 07 Jun 2015 21:02:53 +0800</pubDate>
      <guid>https://libla.me/posts/2015/06/07/csnative/</guid>
      <description>Unity3D采用C#作为脚本开发语言，本来是可以直接提供代码局部更新机制的，可惜Mono和Unity3D迫于苹果的压力，在iOS上采用AO</description>
    </item>
  </channel>
</rss>
